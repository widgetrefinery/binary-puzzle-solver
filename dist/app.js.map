{"version":3,"sources":["webpack:/webpack/bootstrap d6711a0e73959738a435","webpack:///src/js/index.js","webpack:///src/js/cells.js","webpack:///src/js/config.js","webpack:///src/js/solver.js","webpack:///src/js/row.js"],"names":["__webpack_require__","moduleId","installedModules","exports","module","id","loaded","modules","call","m","c","p","cellComponent","solver","x","y","component","toggle","cells","dirty","view","class","changes","onclick","value","rowComponent","cellComponents","Array","size","board","running","undefined","speed","create","resize","e","target","run","clearTimeout","runCallback","solve","hasData","setTimeout","redraw","step","rows","onchange","mount","document","body","getCell","values","getValue","unknown","inferValueFromNeighbors","cell","neighbor1","neighbor2","zero","one","config","i","length","queued","get","infer","left2","left1","right1","above2","above1","below1","hasNeighbor","resetSolver","cols","queue","row","queueCell","set","queueRow","queueColumn","push","type","r","queueUnknownNeighbors","queueUnknownNeighbor","dx","dy","neighbor","handleModifiedCell","updateRow","updateColumn","checkCell","checkRow","perms","perm","remove","checkColumn","entry","pop","console","log","import","export","computePermutations","permutationCache","permutations","permutation","halfSize","offset","isValidPermutation","join","firstOne","nextZero","slice","count","modified","splice","_compute","_isValid"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d6711a0e73959738a435","var cells = require(\"./cells.js\");\nvar solver = require(\"./solver.js\");\n\nfunction cellComponent(solver, x, y) {\n\tvar component = {\n\t\ttoggle: function() {\n\t\t\tcells.toggle(solver.cells, x, y);\n\t\t\tsolver.dirty = true;\n\t\t},\n\t\tview: function() {\n\t\t\treturn m(\"span\", {\n\t\t\t\tclass: solver.changes && solver.changes[x + \",\" + y] ? \"active\" : \"\",\n\t\t\t\tonclick: component.toggle\n\t\t\t}, cells.value(solver.cells, x, y));\n\t\t}\n\t};\n\treturn m(component);\n}\n\nfunction rowComponent(solver, y) {\n\tvar component = {\n\t\tview: function() {\n\t\t\tvar cellComponents = new Array(solver.size);\n\t\t\tfor (var x = 0; x < solver.size; x++) {\n\t\t\t\tcellComponents[x] = cellComponent(solver, x, y);\n\t\t\t}\n\t\t\treturn m(\"div\", cellComponents);\n\t\t}\n\t};\n\treturn m(component);\n}\n\nvar board = {\n\trunning: undefined,\n\tspeed: 200,\n\tsolver: solver.create(6),\n\tresize: function(e) {\n\t\tvar size = e.target.value | 0;\n\t\tboard.solver = solver.create(size);\n\t},\n\trun: function() {\n\t\tif (board.running) {\n\t\t\tclearTimeout(board.running);\n\t\t\tboard.running = undefined;\n\t\t} else {\n\t\t\tboard.runCallback();\n\t\t}\n\t},\n\trunCallback: function() {\n\t\tsolver.solve(board.solver);\n\t\tif (board.solver.changes.hasData) {\n\t\t\tboard.running = setTimeout(board.runCallback, board.speed);\n\t\t} else {\n\t\t\tboard.running = undefined;\n\t\t}\n\t\tm.redraw();\n\t},\n\tstep: function() {\n\t\tsolver.solve(board.solver);\n\t},\n\tview: function() {\n\t\tvar rows = new Array(board.solver.size);\n\t\tfor (var y = 0; y < board.solver.size; y++) {\n\t\t\trows[y] = rowComponent(board.solver, y);\n\t\t}\n\t\treturn m(\"div\", [\n\t\t\tm(\"select\", {\n\t\t\t\tonchange: board.resize\n\t\t\t}, [\n\t\t\t\tm(\"option\", {\n\t\t\t\t\tvalue: 6\n\t\t\t\t}, \"6x6\"),\n\t\t\t\tm(\"option\", {\n\t\t\t\t\tvalue: 8\n\t\t\t\t}, \"8x8\"),\n\t\t\t\tm(\"option\", {\n\t\t\t\t\tvalue: 10\n\t\t\t\t}, \"10x10\"),\n\t\t\t\tm(\"option\", {\n\t\t\t\t\tvalue: 12\n\t\t\t\t}, \"12x12\")\n\t\t\t]),\n\t\t\tm(\"button\", {\n\t\t\t\tonclick: board.step\n\t\t\t}, \"step\"),\n\t\t\tm(\"button\", {\n\t\t\t\tonclick: board.run\n\t\t\t}, board.running ? \"stop\" : \"run\"),\n\t\t\tm(\"div\", {\n\t\t\t\tclass: \"board\"\n\t\t\t}, rows)\n\t\t]);\n\t}\n};\n\nm.mount(document.body, board);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/index.js\n// module id = 0\n// module chunks = 0","var config = require(\"./config.js\");\n\nvar unknown = config.cell.unknown;\nvar zero = config.cell.zero;\nvar one = config.cell.one;\n\n/**\n * Create an object to hold the state for the cells on the puzzle board.\n *\n * @param {!number} size - board size; assumed to be a positive, even number\n * @return {!object} cell states\n */\nfunction createCells(size) {\n\tvar values = new Array(size * size);\n\tfor (var i = 0; i < values.length; i++) {\n\t\tvalues[i] = {\n\t\t\tvalue: unknown,\n\t\t\tqueued: false\n\t\t};\n\t}\n\treturn {\n\t\tsize: size,\n\t\tvalues: values\n\t};\n}\n\n/**\n * Get the state for a single cell. This will return undefined if the coordinates are out of bounds.\n *\n * @param {!object} cells - cell states\n * @param {!number} x - x-axis coordinate for the cell\n * @param {!number} y - y-axis coordinate for the cell\n * @return {?object} cell state or undefined\n */\nfunction getCell(cells, x, y) {\n\tif (0 <= x && x < cells.size && 0 <= y && y < cells.size) {\n\t\treturn cells.values[cells.size * y + x];\n\t}\n\treturn undefined;\n}\n\n/**\n * Get the value for a single cell. This will return unknown if the coordinates are out of bounds.\n *\n * @param {!object} cells - cell states\n * @param {!number} x - x-axis coordinate for the cell\n * @param {!number} y - y-axis coordinate for the cell\n * @return {!string} zero, one, or unknown\n */\nfunction getValue(cells, x, y) {\n\tif (0 <= x && x < cells.size && 0 <= y && y < cells.size) {\n\t\treturn cells.values[cells.size * y + x].value;\n\t}\n\treturn unknown;\n}\n\n/**\n * Toggle the value for a single cell. It will cycle through zero, one, unknown.\n *\n * @param {!object} cells - cell states\n * @param {!number} x - x-axis coordinate for the cell; assumed to be within bounds\n * @param {!number} y - y-axis coordinate for the cell; assumed to be within bounds\n */\nfunction toggleValue(cells, x, y) {\n\tvar cell = getCell(cells, x, y);\n\tif (unknown === cell.value) {\n\t\tcell.value = zero;\n\t} else if (zero === cell.value) {\n\t\tcell.value = one;\n\t} else {\n\t\tcell.value = unknown;\n\t}\n}\n\n/**\n * Try to infer the value for a cell by inspecting its neighbors.\n *\n * @param {!object} cells - cell states\n * @param {!number} x - x-axis coordinate for the cell; assumed to be within bounds\n * @param {!number} y - y-axis coordinate for the cell; assumed to be within bounds\n * @return {!string} cell value\n */\nfunction inferValue(cells, x, y) {\n\tvar cell = getCell(cells, x, y);\n\t// check the 2 cells to the left\n\tvar left2 = getValue(cells, x - 2, y);\n\tvar left1 = getValue(cells, x - 1, y);\n\tif (inferValueFromNeighbors(cell, left2, left1)) {\n\t\treturn cell.value;\n\t}\n\t// check the cells immediately to the left and right\n\tvar right1 = getValue(cells, x + 1, y);\n\tif (inferValueFromNeighbors(cell, left1, right1)) {\n\t\treturn cell.value;\n\t}\n\t// check the 2 cells to the right\n\tvar right2 = getValue(cells, x + 2, y);\n\tif (inferValueFromNeighbors(cell, right1, right2)) {\n\t\treturn cell.value;\n\t}\n\t// check the 2 cells above\n\tvar above2 = getValue(cells, x, y - 2);\n\tvar above1 = getValue(cells, x, y - 1);\n\tif (inferValueFromNeighbors(cell, above1, above2)) {\n\t\treturn cell.value;\n\t}\n\t// check the cells immediately above and below\n\tvar below1 = getValue(cells, x, y + 1);\n\tif (inferValueFromNeighbors(cell, above1, below1)) {\n\t\treturn cell.value;\n\t}\n\t// check the 2 cells below\n\tvar below2 = getValue(cells, x, y + 2);\n\tif (inferValueFromNeighbors(cell, below1, below2)) {\n\t\treturn cell.value;\n\t}\n\t// not enough information to determine value\n\treturn unknown;\n}\n\n/**\n * Try to infer the value for a cell by inspecting the given neighbors.\n *\n * @param {!object} cell - cell state\n * @param {!string} neighbor1 - value from the first neighbor\n * @param {!string} neighbor2 - value from the second neighbor\n * @return {!boolean} true if the cell value is now set\n */\nfunction inferValueFromNeighbors(cell, neighbor1, neighbor2) {\n\tif (unknown !== neighbor1 && neighbor1 === neighbor2) {\n\t\tcell.value = zero === neighbor1 ? one : zero;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Test if any of the immediate neighbors around a cell are set.\n *\n * @param {!object} cells - cell states\n * @param {!number} x - x-axis coordinate for the cell\n * @param {!number} y - y-axis coordinate for the cell\n * @return {!boolean} true if any immediate neighbors are set\n */\nfunction hasNeighbor(cells, x, y) {\n\treturn unknown !== getValue(cells, x - 1, y) ||\n\t\tunknown !== getValue(cells, x + 1, y) ||\n\t\tunknown !== getValue(cells, x, y - 1) ||\n\t\tunknown !== getValue(cells, x, y + 1);\n}\n\nmodule.exports = {\n\tcreate: createCells,\n\tget: getCell,\n\tvalue: getValue,\n\ttoggle: toggleValue,\n\tinfer: inferValue,\n\thasNeighbor: hasNeighbor\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/cells.js\n// module id = 1\n// module chunks = 0","module.exports = {\n\tcell: {\n\t\tunknown: \"\",\n\t\tzero: \"0\",\n\t\tone: \"1\"\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/config.js\n// module id = 2\n// module chunks = 0","var config = require(\"./config.js\");\nvar cells = require(\"./cells.js\");\nvar row = require(\"./row.js\");\n\nvar unknown = config.cell.unknown;\nvar zero = config.cell.zero;\nvar one = config.cell.one;\n\nfunction createSolver(size) {\n\treturn {\n\t\tsize: size,\n\t\tdirty: true,\n\t\tcells: cells.create(size),\n\t\trows: undefined,\n\t\tcols: undefined,\n\t\tqueue: undefined,\n\t\tchanges: undefined\n\t};\n}\n\nfunction importValues(solver, values) {\n\tsolver.dirty = true;\n\tvar i = 0;\n\tfor (var y = 0; y < solver.size; y++) {\n\t\tfor (var x = 0; x < solver.size; x++) {\n\t\t\tvar value = i < values.length ? values[i] : \" \";\n\t\t\ti++;\n\t\t\tvar cell = cells.get(solver.cells, x, y);\n\t\t\tif (\"0\" === value) {\n\t\t\t\tcell.value = zero;\n\t\t\t} else if (\"1\" === value) {\n\t\t\t\tcell.value = one;\n\t\t\t} else {\n\t\t\t\tcell.value = unknown;\n\t\t\t}\n\t\t}\n\t\ti++; // skip over newline\n\t}\n}\n\nfunction exportValues(solver) {\n\tvar values = \"\";\n\tfor (var y = 0; y < solver.size; y++) {\n\t\tif (0 < y) {\n\t\t\tvalues += \"\\n\";\n\t\t}\n\t\tfor (var x = 0; x < solver.size; x++) {\n\t\t\tvar value = cells.value(solver.cells, x, y);\n\t\t\tif (zero === value) {\n\t\t\t\tvalues += \"0\";\n\t\t\t} else if (one === value) {\n\t\t\t\tvalues += \"1\";\n\t\t\t} else {\n\t\t\t\tvalues += \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn values;\n}\n\nfunction solve(solver) {\n\tif (solver.dirty) {\n\t\tsolver.dirty = false;\n\t\tresetSolver(solver);\n\t}\n\tsolver.changes = {\n\t\thasData: false\n\t};\n\twhile (!solver.changes.hasData && 0 < solver.queue.length) {\n\t\tvar entry = solver.queue.pop();\n\t\tif (\"cell\" === entry.type) {\n\t\t\tcheckCell(solver, entry.x, entry.y);\n\t\t} else if (\"row\" === entry.type) {\n\t\t\tcheckRow(solver, entry.y);\n\t\t} else if (\"column\" === entry.type) {\n\t\t\tcheckColumn(solver, entry.x);\n\t\t} else {\n\t\t\tconsole.log(\"unknown queue entry: \" + entry);\n\t\t}\n\t}\n}\n\nfunction resetSolver(solver) {\n\tsolver.rows = new Array(solver.size);\n\tsolver.cols = new Array(solver.size);\n\tsolver.queue = [];\n\tfor (var i = 0; i < solver.size; i++) {\n\t\tsolver.rows[i] = row.create(solver.size);\n\t\tsolver.cols[i] = row.create(solver.size);\n\t}\n\n\tfor (var y = 0; y < solver.size; y++) {\n\t\tfor (var x = 0; x < solver.size; x++) {\n\t\t\tvar cell = cells.get(solver.cells, x, y);\n\t\t\tcell.queued = false;\n\t\t\tif (unknown === cell.value) {\n\t\t\t\tif (cells.hasNeighbor(solver.cells, x, y)) {\n\t\t\t\t\tqueueCell(solver, x, y);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (row.set(solver.rows[y], x, cell.value)) {\n\t\t\t\t\tqueueRow(solver, y);\n\t\t\t\t}\n\t\t\t\tif (row.set(solver.cols[x], y, cell.value)) {\n\t\t\t\t\tqueueColumn(solver, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction queueCell(solver, x, y) {\n\tvar cell = cells.get(solver.cells, x, y);\n\tif (!cell.queued) {\n\t\tcell.queued = true;\n\t\tsolver.queue.push({\n\t\t\ttype: \"cell\",\n\t\t\tx: x,\n\t\t\ty: y\n\t\t});\n\t}\n}\n\nfunction queueRow(solver, y) {\n\tvar r = solver.rows[y];\n\tif (!r.queued) {\n\t\tr.queued = true;\n\t\tsolver.queue.push({\n\t\t\ttype: \"row\",\n\t\t\ty: y\n\t\t});\n\t}\n}\n\nfunction queueColumn(solver, x) {\n\tvar c = solver.cols[x];\n\tif (!c.queued) {\n\t\tc.queued = true;\n\t\tsolver.queue.push({\n\t\t\ttype: \"column\",\n\t\t\tx: x\n\t\t});\n\t}\n}\n\nfunction queueUnknownNeighbors(solver, x, y) {\n\t// queue neighbors to the left\n\tqueueUnknownNeighbor(solver, x, y, -1, 0);\n\t// queue neighbors to the right\n\tqueueUnknownNeighbor(solver, x, y, 1, 0);\n\t// queue neighbors above\n\tqueueUnknownNeighbor(solver, x, y, 0, -1);\n\t// queue neighbors below\n\tqueueUnknownNeighbor(solver, x, y, 0, 1);\n}\n\nfunction queueUnknownNeighbor(solver, x, y, dx, dy) {\n\tx += dx;\n\ty += dy;\n\tvar neighbor = cells.get(solver.cells, x, y);\n\tif (undefined !== neighbor && unknown === neighbor.value) {\n\t\tqueueCell(solver, x, y);\n\t} else {\n\t\tx += dx;\n\t\ty += dy;\n\t\tneighbor = cells.get(solver.cells, x, y);\n\t\tif (undefined !== neighbor && unknown === neighbor.value) {\n\t\t\tqueueCell(solver, x, y);\n\t\t}\n\t}\n}\n\nfunction handleModifiedCell(solver, x, y, value, updateRow, updateColumn) {\n\tsolver.changes.hasData = true;\n\tsolver.changes[x + \",\" + y] = true;\n\tqueueUnknownNeighbors(solver, x, y);\n\tif (updateRow && row.set(solver.rows[y], x, value)) {\n\t\tqueueRow(solver, y);\n\t}\n\tif (updateColumn && row.set(solver.cols[x], y, value)) {\n\t\tqueueColumn(solver, x);\n\t}\n}\n\nfunction checkCell(solver, x, y) {\n\tvar cell = cells.get(solver.cells, x, y);\n\tcell.queued = false;\n\tif (unknown === cell.value && unknown !== cells.infer(solver.cells, x, y)) {\n\t\thandleModifiedCell(solver, x, y, cell.value, true, true);\n\t}\n}\n\nfunction checkRow(solver, y) {\n\tvar r = solver.rows[y];\n\tr.queued = false;\n\n\tfor (var x = 0; x < solver.size; x++) {\n\t\tvar cell = cells.get(solver.cells, x, y);\n\t\tif (unknown !== cell.value) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar value = row.get(r, x);\n\t\tif (unknown === value) {\n\t\t\tcontinue;\n\t\t}\n\t\tcell.value = value;\n\t\thandleModifiedCell(solver, x, y, value, false, true);\n\t}\n\n\tif (1 === r.perms.length) {\n\t\tvar perm = r.perms[0];\n\t\tfor (var i = 0; i < solver.size; i++) {\n\t\t\tif (i !== y && row.remove(solver.rows[i], perm)) {\n\t\t\t\tqueueRow(solver, i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkColumn(solver, x) {\n\tvar c = solver.cols[x];\n\tc.queued = false;\n\n\tfor (var y = 0; y < solver.size; y++) {\n\t\tvar cell = cells.get(solver.cells, x, y);\n\t\tif (unknown !== cell.value) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar value = row.get(c, y);\n\t\tif (unknown === value) {\n\t\t\tcontinue;\n\t\t}\n\t\tcell.value = value;\n\t\thandleModifiedCell(solver, x, y, value, true, false);\n\t}\n\n\tif (1 === c.perms.length) {\n\t\tvar perm = c.perms[0];\n\t\tfor (var i = 0; i < solver.size; i++) {\n\t\t\tif (i !== x && row.remove(solver.cols[i], perm)) {\n\t\t\t\tqueueColumn(solver, i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = {\n\tcreate: createSolver,\n\tsolve: solve,\n\timport: importValues,\n\texport: exportValues\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/solver.js\n// module id = 3\n// module chunks = 0","var config = require(\"./config.js\");\n\nvar unknown = config.cell.unknown;\nvar zero = config.cell.zero;\nvar one = config.cell.one;\n\n/**\n * {@link #computePermutations} caches any computed permutations here. The cache key is the row size\n * while the cache value is the list of permutations.\n *\n * @var {Object<number,string[]>}\n */\nvar permutationCache = {};\n\n/**\n * Compute the permutations for a row with a certain size.\n *\n * @param {!number} size - row size; assumed to be a positive, even number\n * @return {string[]} list of permutations\n */\nfunction computePermutations(size) {\n\tif (!permutationCache[size]) {\n\t\tvar permutations = [];\n\t\tpermutationCache[size] = permutations;\n\t\t// create initial permutation with left-half as ones and right-half as zeros\n\t\tvar permutation = new Array(size);\n\t\tvar halfSize = size / 2;\n\t\tfor (var offset = 0; offset < halfSize; offset++) {\n\t\t\tpermutation[offset] = one;\n\t\t\tpermutation[halfSize + offset] = zero;\n\t\t}\n\t\t// save initial permutation if valid\n\t\tif (isValidPermutation(permutation)) {\n\t\t\tpermutations.push(permutation.join(\"\"));\n\t\t}\n\t\t// generate other permutations by shuffling the values around\n\t\twhile (true) {\n\t\t\t// seek to the first offset that contains a one\n\t\t\tvar firstOne = 0;\n\t\t\twhile (zero === permutation[firstOne]) {\n\t\t\t\tfirstOne++;\n\t\t\t}\n\t\t\tif (firstOne >= halfSize) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// seek to the next zero\n\t\t\tvar nextZero = firstOne + 1;\n\t\t\twhile (one === permutation[nextZero]) {\n\t\t\t\tnextZero++;\n\t\t\t}\n\t\t\t// swap the one and zero on the right edge of the group\n\t\t\tpermutation[nextZero - 1] = zero;\n\t\t\tpermutation[nextZero] = one;\n\t\t\t// move the remaining ones back to the left edge of the row\n\t\t\tfor (var offset = firstOne; offset < nextZero - 1; offset++) {\n\t\t\t\tpermutation[offset] = zero;\n\t\t\t\tpermutation[offset - firstOne] = one;\n\t\t\t}\n\t\t\t// save the permutation if valid\n\t\t\tif (isValidPermutation(permutation)) {\n\t\t\t\tpermutations.push(permutation.join(\"\"));\n\t\t\t}\n\t\t}\n\t}\n\t// return a copy of the permutations\n\treturn permutationCache[size].slice();\n}\n\n/**\n * Test if the permutation is valid. A permutation is valid if it contains no more than 2 ones or\n * zeros grouped together.\n *\n * An example of a valid permutation: \"011010\"\n *\n * An example of an invalid permutation: \"011100\"\n *\n * @param {!string} permutation - permutation to test; assumed to contain an even number of ones and zeros\n * @return {!boolean} true if the permutation is valid\n */\nfunction isValidPermutation(permutation) {\n\tvar value = permutation[0];\n\tvar count = 1;\n\tfor (var offset = 1; offset < permutation.length; offset++) {\n\t\tif (value === permutation[offset]) {\n\t\t\tcount++;\n\t\t\tif (2 < count) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = permutation[offset];\n\t\t\tcount = 1;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Create an object to hold the state for a row (or column). It keeps track of the list of valid\n * permutations for the row.\n *\n * @param {!number} size - row size; assumed to be a positive, even number\n * @return {!object} row state\n */\nfunction createRow(size) {\n\treturn {\n\t\tperms: computePermutations(size),\n\t\tqueued: false\n\t};\n}\n\n/**\n * Get the value at a particular offset if it is defined. The value is defined when the permutations\n * agree to the same value for the offset.\n *\n * @param {!object} row - row state\n * @param {!number} offset - offset into the row\n * @return {!string} zero, one, or unknown\n */\nfunction getValue(row, offset) {\n\tvar value = row.perms[0][offset];\n\tfor (var i = 1; i < row.perms.length; i++) {\n\t\tif (value !== row.perms[i][offset]) {\n\t\t\treturn unknown;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * Set the value at a particular offset. This will remove any permutations that do not agree with\n * the value.\n *\n * @param {!object} row - row state\n * @param {!number} offset - offset into the row\n * @param {!string} value - value at the offset\n * @return {!boolean} true if the row state was modified\n */\nfunction setValue(row, offset, value) {\n\tvar modified = false;\n\tfor (var i = row.perms.length - 1; 0 <= i; i--) {\n\t\tif (row.perms[i][offset] !== value) {\n\t\t\trow.perms.splice(i, 1);\n\t\t\tmodified = true;\n\t\t}\n\t}\n\treturn modified;\n}\n\n/**\n * Remove a permutation from the row.\n *\n * @param {!object} row - row state\n * @param {!string} permutation - permutation to remove\n * @return {!boolean} true if the row state was modified\n */\nfunction removePermutation(row, permutation) {\n\tvar modified = false;\n\tfor (var i = row.perms.length - 1; 0 <= i; i--) {\n\t\tif (row.perms[i] === permutation) {\n\t\t\trow.perms.splice(i, 1);\n\t\t\tmodified = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn modified;\n}\n\nmodule.exports = {\n\tcreate: createRow,\n\tget: getValue,\n\tset: setValue,\n\tremove: removePermutation,\n\t// these are only exposed for unit tests\n\t_compute: computePermutations,\n\t_isValid: isValidPermutation\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/row.js\n// module id = 4\n// module chunks = 0"]}