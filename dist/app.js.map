{"version":3,"sources":["webpack:/webpack/bootstrap 6c5bcff3be4fb8e08617","webpack:///src/js/index.js","webpack:///src/js/cells.js","webpack:///src/js/config.js","webpack:///src/js/engine.js","webpack:///src/js/rows.js"],"names":["__webpack_require__","moduleId","installedModules","exports","module","id","loaded","modules","call","m","c","p","Cells","Config","Engine","boardSizes","userFlag","cellFlag","user","solvedFlag","solved","cellComponent","classes","engine","x","y","flags","at","cells","rotate","dirty","view","vnode","attrs","class","onclick","get","rowComponent","Array","size","length","boardComponent","rows","rootComponent","create","resizeOptions","options","i","value","selected","resize","stop","clearAll","clear","reset","step","startStop","timer","start","redraw","solve","state","onchange","withAttr","title","trust","mount","document","body","getCell","all","getState","nilFlag","nil","unknownState","cellState","unknown","zeroState","zero","oneState","one","boardSize","set","cell","push","clearSolvedFlag","import","data","lines","split","export","output","engineSpeed","createEngine","undefined","cols","position","initializeEngine","maxPosition","modified","checkRow","checkColumn","Rows","callback","run","setTimeout","clearTimeout","indexOf","computePermutations","rowSize","permutationCache","rawPermutations","rawPermutation","cellPair","zeroCell","oneCell","offset","isPermutationValid","firstOneOffset","nextZeroOffset","priorCell","count","currentCell","mergePermutations","mergedPermutation","cleanupPermutations","row","raw","otherRow","j","splice","slice","merged","rowOffset","cellOffset","expectedCell","_isPermutationValid"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6c5bcff3be4fb8e08617","var Cells = require(\"./cells.js\");\nvar Config = require(\"./config.js\");\nvar Engine = require(\"./engine.js\");\n\nvar boardSizes = Config.boardSizes;\n\nvar userFlag = Config.cellFlag.user;\nvar solvedFlag = Config.cellFlag.solved;\n\nvar cellComponent = {\n\tclasses: function(engine, x, y) {\n\t\tvar flags = Cells.at(engine.cells, x, y).flags;\n\t\tif (userFlag === flags) {\n\t\t\treturn \"user\";\n\t\t}\n\t\tif (solvedFlag === flags) {\n\t\t\treturn \"solved\";\n\t\t}\n\t\treturn undefined;\n\t},\n\trotate: function(engine, x, y) {\n\t\tCells.rotate(engine.cells, x, y);\n\t\tengine.dirty = true;\n\t},\n\tview: function(vnode) {\n\t\tvar engine = vnode.attrs.engine;\n\t\tvar x = vnode.attrs.x;\n\t\tvar y = vnode.attrs.y;\n\t\treturn m(\"td\", {\n\t\t\tclass: cellComponent.classes(engine, x, y),\n\t\t\tonclick: function() {\n\t\t\t\tcellComponent.rotate(engine, x, y);\n\t\t\t}\n\t\t}, Cells.get(engine.cells, x, y));\n\t}\n};\n\nvar rowComponent = {\n\tview: function(vnode) {\n\t\tvar engine = vnode.attrs.engine;\n\t\tvar y = vnode.attrs.y;\n\t\tvar cells = new Array(engine.size);\n\t\tfor (var x = 0; x < cells.length; x++) {\n\t\t\tcells[x] = m(cellComponent, {\n\t\t\t\tengine: engine,\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\t}\n\t\treturn m(\"tr\", cells);\n\t}\n};\n\nvar boardComponent = {\n\tview: function(vnode) {\n\t\tvar engine = vnode.attrs.engine;\n\t\tvar rows = new Array(engine.size);\n\t\tfor (var y = 0; y < rows.length; y++) {\n\t\t\trows[y] = m(rowComponent, {\n\t\t\t\tengine: engine,\n\t\t\t\ty: y\n\t\t\t});\n\t\t}\n\t\treturn m(\"table.board\", {\n\t\t\tclass: engine.size & 2 ? \"odd\" : \"even\"\n\t\t}, rows);\n\t}\n};\n\nvar rootComponent = {\n\tengine: Engine.create(8),\n\tresizeOptions: function() {\n\t\tvar options = new Array(boardSizes.length);\n\t\tfor (var i = 0; i < options.length; i++) {\n\t\t\tvar size = boardSizes[i];\n\t\t\toptions[i] = m(\"option\", {\n\t\t\t\tvalue: size,\n\t\t\t\tselected: size === rootComponent.engine.size\n\t\t\t}, size + \"x\" + size);\n\t\t}\n\t\treturn options;\n\t},\n\tresize: function(size) {\n\t\tEngine.stop(rootComponent.engine);\n\t\trootComponent.engine = Engine.create(size | 0);\n\t},\n\tclearAll: function() {\n\t\trootComponent.engine = Engine.create(rootComponent.engine.size);\n\t},\n\tclear: function() {\n\t\tCells.reset(rootComponent.engine.cells);\n\t\trootComponent.engine.dirty = true;\n\t},\n\tstep: function() {\n\t\tEngine.step(rootComponent.engine);\n\t},\n\tstartStop: function() {\n\t\tif (rootComponent.engine.timer) {\n\t\t\tEngine.stop(rootComponent.engine);\n\t\t} else {\n\t\t\tEngine.start(rootComponent.engine, m.redraw);\n\t\t}\n\t},\n\tsolve: function() {\n\t\twhile (Engine.step(rootComponent.engine));\n\t},\n\tview: function(vnode) {\n\t\tvar state = vnode.state;\n\t\tvar engine = state.engine;\n\t\treturn m(\"main\", [\n\t\t\tm(\"fieldset\", [\n\t\t\t\tm(\"select\", {\n\t\t\t\t\tonchange: m.withAttr(\"value\", state.resize),\n\t\t\t\t\ttitle: \"Board Size\"\n\t\t\t\t}, state.resizeOptions()),\n\t\t\t\tm(\"span.btn-group\", [\n\t\t\t\t\tm(\"button\", {\n\t\t\t\t\t\tonclick: state.clearAll,\n\t\t\t\t\t\ttitle: \"Clear all cells.\"\n\t\t\t\t\t}, \"Clear All\"),\n\t\t\t\t\tm(\"button\", {\n\t\t\t\t\t\tonclick: state.clear,\n\t\t\t\t\t\ttitle: \"Clear computed cells, leaving user-defind cells on the board.\"\n\t\t\t\t\t}, \"Clear\")\n\t\t\t\t]),\n\t\t\t\tm(\"span.btn-group\", [\n\t\t\t\t\tm(\"button\", {\n\t\t\t\t\t\tonclick: state.step,\n\t\t\t\t\t\ttitle: \"Look for some cells that can be solved and solve them.\"\n\t\t\t\t\t}, \"Step\"),\n\t\t\t\t\tm(\"button\", {\n\t\t\t\t\t\tonclick: state.startStop,\n\t\t\t\t\t\ttitle: \"Repeatedly call Step until there are no more cells that can be solved. A delay is inserted in between calls.\"\n\t\t\t\t\t}, engine.timer ? \"Stop\" : \"Run\"),\n\t\t\t\t\tm(\"button\", {\n\t\t\t\t\t\tonclick: state.solve,\n\t\t\t\t\t\ttitle: \"Repeatedly call Step until there are no more cells that can be solved.\"\n\t\t\t\t\t}, \"Solve\")\n\t\t\t\t])\n\t\t\t]),\n\t\t\tm(boardComponent, {\n\t\t\t\tengine: engine\n\t\t\t}),\n\t\t\tm(\"p\", m.trust(\"This is an application for solving puzzles from <a href=\\\"http://binarypuzzle.com\\\" target=\\\"_blank\\\">http://binarypuzzle.com</a>. To use it:\")),\n\t\t\tm(\"ol\", [\n\t\t\t\tm(\"li\", \"Choose the board size using the upper left dropdown.\"),\n\t\t\t\tm(\"li\", \"Fill in the initial board state by clicking on the board cells.\"),\n\t\t\t\tm(\"li\", \"Click on the Solve button in the upper right.\")\n\t\t\t]),\n\t\t\tm(\"p\", m.trust(\"This is a pet project created for fun. It is not affiliated with <a href=\\\"http://binarypuzzle.com\\\" target=\\\"_blank\\\">http://binarypuzzle.com</a>.\"))\n\t\t]);\n\t}\n};\n\nm.mount(document.body, rootComponent);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/index.js\n// module id = 0\n// module chunks = 0","/** @module cells */\n\nvar Config = require(\"./config.js\");\n\nvar nilFlag = Config.cellFlag.nil;\nvar userFlag = Config.cellFlag.user;\nvar solvedFlag = Config.cellFlag.solved;\n\nvar unknownState = Config.cellState.unknown;\nvar zeroState = Config.cellState.zero;\nvar oneState = Config.cellState.one;\n\n/**\n * Keeps track of the state for a single cell on a board.\n * @typedef {Object} Cell\n * @property {!module:config~CellState} state - cell state\n * @property {!module:config~CellFlag} flags - cell flags\n */\n\n/**\n * Holds the cells for a board.\n * @typedef {Object} Cells\n * @property {!number} size - board size\n * @property {!module:cells~Cell[]} all - board cells\n * @property {!module:cells~Cell[]} solved - cells with the solved flag\n */\n\n/**\n * Create the cells for a board.\n * @param {!number} boardSize - board size; assumed to be a positive, even number\n * @return {!module:cells~Cells} cells for the board\n */\nfunction createCells(boardSize) {\n\tvar cells = new Array(boardSize * boardSize);\n\tfor (var i = 0; i < cells.length; i++) {\n\t\tcells[i] = {\n\t\t\tstate: unknownState,\n\t\t\tflags: nilFlag\n\t\t};\n\t}\n\treturn {\n\t\tsize: boardSize,\n\t\tall: cells,\n\t\tsolved: []\n\t};\n}\n\n/**\n * Get a cell from a board.\n * @param {!module:cells~Cells} cells - cells on a board\n * @param {!number} x - x-coordinate for the cell\n * @param {!number} y - y-coordinate for the cell\n * @return {!module:cells~Cell} the requestd cell\n */\nfunction getCell(cells, x, y) {\n\treturn cells.all[cells.size * y + x];\n}\n\n/**\n * Get the state for a cell.\n * @param {!module:cells~Cells} cells - cells on a board\n * @param {!number} x - x-coordinate for the cell\n * @param {!number} y - y-coordinate for the cell\n * @return {!module:config~CellState} the requested cell state\n */\nfunction getState(cells, x, y) {\n\treturn getCell(cells, x, y).state;\n}\n\n/**\n * Set the state for a cell. This function implies the state is set by the engine.\n * @param {!module:cells~Cells} cells - cells on a board\n * @param {!number} x - x-coordinate for the cell\n * @param {!number} y - y-coordinate for the cell\n * @param {!module:config~CellState} state - cell state to store\n */\nfunction setState(cells, x, y, state) {\n\tvar cell = getCell(cells, x, y);\n\tcell.state = state;\n\tif (solvedFlag !== cell.flags) {\n\t\tcell.flags = solvedFlag;\n\t\tcells.solved.push(cell);\n\t}\n}\n\n/**\n * Rotate a cell through the possible states. This function implies the state is set by the user.\n * @param {!module:cells~Cells} cells - cells on a board\n * @param {!number} x - x-coordinate for the cell\n * @param {!number} y - y-coordinate for the cell\n */\nfunction rotateState(cells, x, y) {\n\tvar cell = getCell(cells, x, y);\n\tif (unknownState === cell.state) {\n\t\tcell.state = zeroState;\n\t\tcell.flags = userFlag;\n\t} else if (zeroState === cell.state) {\n\t\tcell.state = oneState;\n\t\tcell.flags = userFlag;\n\t} else {\n\t\tcell.state = unknownState;\n\t\tcell.flags = nilFlag;\n\t}\n}\n\n/**\n * Remove the solved flag from all cells.\n * @param {!module:cells~Cells} cells - cells on a board\n */\nfunction clearSolvedFlag(cells) {\n\tfor (var i = 0; i < cells.solved.length; i++) {\n\t\tvar cell = cells.solved[i];\n\t\tif (solvedFlag === cell.flags) {\n\t\t\tcell.flags = nilFlag;\n\t\t}\n\t}\n\tcells.solved = [];\n}\n\n/**\n * Reset all non-user cells to the unknown state.\n * @param {!module:cells~Cells} cells - cells on a board\n */\nfunction resetStates(cells) {\n\tfor (var i = 0; i < cells.all.length; i++) {\n\t\tvar cell = cells.all[i];\n\t\tif (userFlag !== cell.flags) {\n\t\t\tcell.state = unknownState;\n\t\t\tcell.flags = nilFlag;\n\t\t}\n\t}\n\tcells.solved = [];\n}\n\n/**\n * Import the cell states for a board. Each line in the input data represents a row on the board.\n * Each character on a line represents the state for a cell. The possible characters are:\n * <ul>\n *   <li>\"0\" - zero state</li>\n *   <li>\"1\" - one state</li>\n *   <li>other - unknown state</li>\n * </ul>\n * If the input data is smaller than the board size, the remaining cells will default to the unknown\n * state. Any cells set by this function will be marked as set by the user.\n * @param {!module:cells~Cells} cells - cells on a board\n * @param {!string} data - string describing the cell states\n */\nfunction importStates(cells, data) {\n\tvar lines = data.split(\"\\n\", cells.size);\n\tfor (var y = 0; y < cells.size; y++) {\n\t\tfor (var x = 0; x < cells.size; x++) {\n\t\t\tvar cell = getCell(cells, x, y);\n\t\t\tvar state = y < lines.length && x < lines[y].length ? lines[y][x] : \" \";\n\t\t\tif (\"0\" === state) {\n\t\t\t\tcell.state = zeroState;\n\t\t\t\tcell.flags = userFlag;\n\t\t\t} else if (\"1\" === state) {\n\t\t\t\tcell.state = oneState;\n\t\t\t\tcell.flags = userFlag;\n\t\t\t} else {\n\t\t\t\tcell.state = unknownState;\n\t\t\t\tcell.flags = nilFlag;\n\t\t\t}\n\t\t}\n\t}\n\tcells.solved = [];\n}\n\n/**\n * Export the cell states for a board. Each line in the output data represents a row on the board.\n * Each character on a line represents the state for a cell. The possible characters are:\n * <ul>\n *   <li>\"0\" - zero state</li>\n *   <li>\"1\" - one state</li>\n *   <li>\" \" - unknown state</li>\n * </ul>\n * @param {!module:cells~Cells} cells - cells on a board\n * @return {!string} string describing the cell states\n */\nfunction exportStates(cells) {\n\tvar output = \"\";\n\tfor (var y = 0; y < cells.size; y++) {\n\t\tif (0 < y) {\n\t\t\toutput += \"\\n\";\n\t\t}\n\t\tfor (var x = 0; x < cells.size; x++) {\n\t\t\tvar state = getState(cells, x, y);\n\t\t\tif (zeroState === state) {\n\t\t\t\toutput += \"0\";\n\t\t\t} else if (oneState === state) {\n\t\t\t\toutput += \"1\";\n\t\t\t} else {\n\t\t\t\toutput += \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn output;\n}\n\nmodule.exports = {\n\tcreate: createCells,\n\tat: getCell,\n\tget: getState,\n\tset: setState,\n\trotate: rotateState,\n\tclearSolvedFlag: clearSolvedFlag,\n\treset: resetStates,\n\timport: importStates,\n\texport: exportStates\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/cells.js\n// module id = 1\n// module chunks = 0","/** @module config */\n\n/**\n * Defines the flags for a cell. The possible values are:\n * <ul>\n *   <li>0 - nothing special about the cell</li>\n *   <li>1 - the cell was set by the user</li>\n *   <li>2 - the cell was just solved by the engine</li>\n * </ul>\n * @typedef {number} CellFlag\n */\n\n/**\n * Defines the state for a cell. The possible values are:\n * <ul>\n *   <li>\"0\" - zero state</li>\n *   <li>\"1\" - one state</li>\n *   <li>\"\" - unknown state</li>\n * </ul>\n * @typedef {string} CellState\n */\n\nmodule.exports = {\n\tboardSizes: [6, 8, 10, 12, 14],\n\tcellFlag: {\n\t\tnil: 0,\n\t\tuser: 1,\n\t\tsolved: 2\n\t},\n\tcellState: {\n\t\tunknown: \"\",\n\t\tzero: \"0\",\n\t\tone: \"1\"\n\t},\n\tengineSpeed: 200\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/config.js\n// module id = 2\n// module chunks = 0","/** @module engine */\n\nvar Cells = require(\"./cells.js\");\nvar Config = require(\"./config.js\");\nvar Rows = require(\"./rows.js\");\n\nvar boardSizes = Config.boardSizes;\n\nvar unknownState = Config.cellState.unknown;\nvar zeroState = Config.cellState.zero;\nvar oneState = Config.cellState.one;\n\nvar engineSpeed = Config.engineSpeed;\n\n/**\n * Holds the data for the puzzle solver engine.\n * @typedef {Object} Engine\n * @property {number} size - board size\n * @property {module:cells~Cells} cells - manages the cells on the board\n * @property {module:rows~Rows} rows - manages the rows on the board\n * @property {module:rows~Rows} cols - manages the columns on the board\n * @property {number} position - tracks the next row or column to process\n * @property {boolean} dirty - true if the user modified the board state\n * @property {number} timer - return value from {@link setTimeout}\n */\n\n/**\n * Create an engine for solving puzzle boards with the given size.\n * @param {!number} boardSize - board size; assumed to be a positive, even number\n * @return {!module:engine~Engine} engine for solving puzzles\n */\nfunction createEngine(boardSize) {\n\treturn {\n\t\tsize: boardSize,\n\t\tcells: Cells.create(boardSize),\n\t\trows: undefined,\n\t\tcols: undefined,\n\t\tposition: 0,\n\t\tdirty: true,\n\t\ttimer: undefined\n\t};\n}\n\n/**\n * Process the puzzle board. It will iterate over the board until it finds the answer to an unsolved\n * cell. The engine processes an entire row or column at a time so it may solve more than one cell\n * before returning.\n * @param {!module:engine~Engine} engine - solver engine\n * @return {!boolean} true if it solved at least one cell\n */\nfunction step(engine) {\n\tif (engine.dirty) {\n\t\tengine.dirty = false;\n\t\tinitializeEngine(engine);\n\t}\n\tvar maxPosition = engine.size * 2;\n\tvar position = engine.position;\n\tvar modified = false;\n\tCells.clearSolvedFlag(engine.cells);\n\tdo {\n\t\tposition = (position + 1) % maxPosition;\n\t\tif (position < engine.size) {\n\t\t\tmodified = checkRow(engine, position);\n\t\t} else {\n\t\t\tmodified = checkColumn(engine, position - engine.size);\n\t\t}\n\t} while (!modified && position !== engine.position);\n\tengine.position = position;\n\treturn modified;\n}\n\n/**\n * Initialize the rows and columns used by the engine.\n * @param {!module:engine~Engine} engine - solver engine\n */\nfunction initializeEngine(engine) {\n\tengine.rows = Rows.create(engine.size);\n\tengine.cols = Rows.create(engine.size);\n\tfor (var y = 0; y < engine.size; y++) {\n\t\tfor (var x = 0; x < engine.size; x++) {\n\t\t\tvar state = Cells.get(engine.cells, x, y);\n\t\t\tif (unknownState !== state) {\n\t\t\t\tRows.set(engine.rows, y, x, state);\n\t\t\t\tRows.set(engine.cols, x, y, state);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Process a row looking for answers to any unsolved cells.\n * @param {!module:engine~Engine} engine - solver engine\n * @param {!number} y - identifies the row to proces\n * @return {!boolean} true if at least one cell was solved\n */\nfunction checkRow(engine, y) {\n\tif (!Rows.dirty(engine.rows, y)) {\n\t\treturn false;\n\t}\n\tvar modified = false;\n\tfor (var x = 0; x < engine.size; x++) {\n\t\tvar state = Cells.get(engine.cells, x, y);\n\t\tif (unknownState !== state) {\n\t\t\tcontinue;\n\t\t}\n\t\tstate = Rows.get(engine.rows, y, x);\n\t\tif (unknownState !== state) {\n\t\t\tCells.set(engine.cells, x, y, state, false);\n\t\t\tRows.set(engine.cols, x, y, state);\n\t\t\tmodified = true;\n\t\t}\n\t}\n\treturn modified;\n}\n\n/**\n * Process a column looking for answers to any unsolved cells.\n * @param {!module:engine~Engine} engine - solver engine\n * @param {!number} x - identifies the column to process\n * @return {!boolean} true if at least one cell was solved\n */\nfunction checkColumn(engine, x) {\n\tif (!Rows.dirty(engine.cols, x)) {\n\t\treturn false;\n\t}\n\tvar modified = false;\n\tfor (var y = 0; y < engine.size; y++) {\n\t\tvar state = Cells.get(engine.cells, x, y);\n\t\tif (unknownState !== state) {\n\t\t\tcontinue;\n\t\t}\n\t\tstate = Rows.get(engine.cols, x, y);\n\t\tif (unknownState !== state) {\n\t\t\tCells.set(engine.cells, x, y, state, false);\n\t\t\tRows.set(engine.rows, y, x, state);\n\t\t\tmodified = true;\n\t\t}\n\t}\n\treturn modified;\n}\n\n/**\n * Start processing the puzzle board. It will periodically call {@link module:engine~step} to\n * advance the board state until it cannot solve any more cells.\n * @param {!module:engine~Engine} engine - solver engine\n * @param {?function} callback - invoked on every engine tick\n */\nfunction start(engine, callback) {\n\tif (!engine.timer) {\n\t\trun();\n\t}\n\n\tfunction run() {\n\t\tengine.timer = undefined;\n\t\tif (step(engine)) {\n\t\t\tengine.timer = setTimeout(run, engineSpeed);\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n}\n\n/**\n * Stop processing the puzzle board.\n * @param {!module:engine~Engine} engine - solver engine\n */\nfunction stop(engine) {\n\tif (engine.timer) {\n\t\tclearTimeout(engine.timer);\n\t\tengine.timer = undefined;\n\t}\n}\n\n/**\n * Create a solver engine for the puzzle board defined by the serialized cell states. The board size\n * is determined by counting the number of characters on the first line. It must match one of the\n * valid board sizes or the import will fail.\n * @param {!string} data - string describing the cell states\n * @return {?module:engine~Engine} solver engine or undefined\n * @see {module:cells~importStates}\n */\nfunction importData(data) {\n\tvar size = undefined;\n\tfor (var i = 0; i < data.length; i++) {\n\t\tif (\"\\n\" === data[i]) {\n\t\t\tsize = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (-1 === boardSizes.indexOf(size)) {\n\t\treturn undefined;\n\t}\n\tvar engine = createEngine(size);\n\tCells.import(engine.cells, data);\n\tengine.dirty = true;\n\treturn engine;\n}\n\n/**\n * Export the cell states from a solver engine.\n * @param {!module:engine~Engine} engine - solver engine\n * @return {!string} string describing the cell states\n * @see {module:cells~exportStates}\n */\nfunction exportData(engine) {\n\treturn Cells.export(engine.cells);\n}\n\nmodule.exports = {\n\tcreate: createEngine,\n\tstep: step,\n\tstart: start,\n\tstop: stop,\n\timport: importData,\n\texport: exportData\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/engine.js\n// module id = 3\n// module chunks = 0","/** @module rows */\n\nvar Config = require(\"./config.js\");\n\nvar unknownState = Config.cellState.unknown;\nvar zeroState = Config.cellState.zero;\nvar oneState = Config.cellState.one;\n\nvar zeroCell = 1;\nvar oneCell = 2;\n\n/**\n * {@link module:rows~computePermutations} caches all computed permutations here. The cache key is\n * the row size while the cache value is the list of permutations.\n * @var {Object<number,module:rows~Permutation[]>}\n */\nvar permutationCache = {};\n\n/**\n * Represents the cell states for a row. Every 2 bits in the integer represents the state for one\n * cell on the row. The possible values for a cell are:\n * <ul>\n *   <li>01 - zero state</li>\n *   <li>10 - one state</li>\n *   <li>other - unknown state (only occurs for merged permutations)</li>\n * </ul>\n * @typedef {number} Permutation\n */\n\n/**\n * Keeps track of the valid permutations for a row (or column) of cells on a board.\n * @typedef {Object} Row\n * @property {!module:rows~Permutation[]} raw - list of valid permutations\n * @property {!module:rows~Permutation} merged - merged permutation value\n * @property {!boolean} dirty - true if raw and merged are out of sync\n */\n\n/**\n * Holds the rows (or columns) for a board.\n * @typedef {module:rows~Row[]} Rows\n */\n\n/**\n * Create the rows for a board.\n * @param {!number} boardSize - board size; assumed to be a positive, even number\n * @return {!module:rows~Rows} rows for the board\n */\nfunction createRows(boardSize) {\n\tvar rows = new Array(boardSize);\n\tvar rawPermutations = computePermutations(boardSize);\n\tvar mergedPermutation = mergePermutations(rawPermutations);\n\tfor (var i = 0; i < rows.length; i++) {\n\t\trows[i] = {\n\t\t\traw: rawPermutations.slice(),\n\t\t\tmerged: mergedPermutation,\n\t\t\tdirty: false\n\t\t};\n\t}\n\treturn rows;\n}\n\n/**\n * Compute the valid permutations for a row with the given size.\n * @param {!number} rowSize - row size; assumed to be a positive, even number\n * @return {!module:rows~Permutation[]} list of permutations\n */\nfunction computePermutations(rowSize) {\n\tif (!permutationCache[rowSize]) {\n\t\tvar rawPermutations = [];\n\t\tpermutationCache[rowSize] = rawPermutations;\n\t\t// create initial permutation with ones in the lower half and zeroes in the upper half\n\t\tvar rawPermutation = 0;\n\t\tvar cellPair = (zeroCell << rowSize) | oneCell;\n\t\tfor (var offset = 0; offset < rowSize; offset += 2) {\n\t\t\trawPermutation |= cellPair << offset;\n\t\t}\n\t\t// save initial permutation if valid\n\t\tif (isPermutationValid(rawPermutation)) {\n\t\t\trawPermutations.push(rawPermutation);\n\t\t}\n\t\t// generate remaining permutations by shuffling the one cells up the row\n\t\twhile (true) {\n\t\t\t// seek to the first cell that contains a one\n\t\t\tvar firstOneOffset = 0;\n\t\t\twhile (oneCell !== ((rawPermutation >>> firstOneOffset) & 0x3)) {\n\t\t\t\tfirstOneOffset += 2;\n\t\t\t}\n\t\t\t// stop when all the ones have migrated to the upper half of the row\n\t\t\tif (firstOneOffset >= rowSize) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// seek to the next zero cell\n\t\t\tvar nextZeroOffset = firstOneOffset + 2;\n\t\t\twhile (zeroCell !== ((rawPermutation >>> nextZeroOffset) & 0x3)) {\n\t\t\t\tnextZeroOffset += 2;\n\t\t\t}\n\t\t\t// move the upper one cell up by one position, move the remaining one cells to the bottom\n\t\t\trawPermutation ^= ((0x4 << (nextZeroOffset - firstOneOffset)) - 1) << firstOneOffset;\n\t\t\trawPermutation ^= (0x1 << (nextZeroOffset - firstOneOffset - 2)) - 1;\n\t\t\t// save the permutation if valid\n\t\t\tif (isPermutationValid(rawPermutation)) {\n\t\t\t\trawPermutations.push(rawPermutation);\n\t\t\t}\n\t\t}\n\t}\n\treturn permutationCache[rowSize];\n}\n\n/**\n * Test if the permutation is valid. A permutation is valid if it contains no more than two\n * consecutive cells with the same state.\n * @param {!module:rows~Permutation} permutation - permutation to test\n * @return {!boolean} true if the permutation is valid\n */\nfunction isPermutationValid(rawPermutation) {\n\tvar priorCell = undefined;\n\tvar count = 0;\n\twhile (0 !== rawPermutation) {\n\t\tvar currentCell = rawPermutation & 0x3;\n\t\tif (currentCell === priorCell) {\n\t\t\tcount++;\n\t\t\tif (2 < count) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tpriorCell = currentCell;\n\t\t\tcount = 1;\n\t\t}\n\t\trawPermutation >>>= 2;\n\t}\n\treturn true;\n}\n\n/**\n * Merge a list of permutations into a single permutation. The output permutation will contain an\n * unknown state for any cells that have conflicting states from the input permutations. Otherwise,\n * the output permutation will contain a zero or one state for a cell to indicate that all input\n * permutations agreed to that state.\n * @param {!module:rows~Permutation[]} rawPermutations - list of permutations for a row\n * @return {!module:rows~Permutation} merged permutation\n */\nfunction mergePermutations(rawPermutations) {\n\tvar mergedPermutation = 0;\n\tfor (var i = 0; i < rawPermutations.length; i++) {\n\t\tmergedPermutation |= rawPermutations[i];\n\t}\n\treturn mergedPermutation;\n}\n\n/**\n * Test if a row is dirty.\n * @param {!module:rows~Rows} rows - rows on a board\n * @param {!number} rowOffset - identifies the row on the board\n * @return {!boolean} true if the row is dirty\n */\nfunction isRowDirty(rows, rowOffset) {\n\treturn rows[rowOffset].dirty;\n}\n\n/**\n * Get the state for a cell. This will update the row if it is dirty.\n * @param {!module:rows~Rows} rows - rows on a board\n * @param {!number} rowOffset - identifies the row on the board\n * @param {!number} cellOffset - identifies the cell on the row\n * @return {!module:config~CellState} the requested cell state\n */\nfunction getState(rows, rowOffset, cellOffset) {\n\tvar row = rows[rowOffset];\n\tif (row.dirty) {\n\t\trow.dirty = false;\n\t\trow.merged = mergePermutations(row.raw);\n\t\tcleanupPermutations(rows, row);\n\t}\n\tvar cell = (row.merged >>> (cellOffset * 2)) & 0x3;\n\tif (zeroCell === cell) {\n\t\treturn zeroState;\n\t}\n\tif (oneCell === cell) {\n\t\treturn oneState;\n\t}\n\treturn unknownState;\n}\n\n/**\n * Set the state for a cell.\n * @param {!module:rows~Rows} rows - rows on a board\n * @param {!number} rowOffset - identifies the row on the board\n * @param {!number} cellOffset - identifies the cell on the row\n * @param {!module:config~CellState} state - cell state to store\n * @return {!boolean} true if any rows were modified\n */\nfunction setState(rows, rowOffset, cellOffset, state) {\n\tvar modified = false;\n\tvar row = rows[rowOffset];\n\tcellOffset *= 2;\n\tvar expectedCell = zeroState === state ? zeroCell : oneCell;\n\tvar rawPermutations = row.raw;\n\tfor (var i = rawPermutations.length - 1; 0 <= i; i--) {\n\t\tvar actualCell = (rawPermutations[i] >>> cellOffset) & 0x3;\n\t\tif (actualCell !== expectedCell) {\n\t\t\trawPermutations.splice(i, 1);\n\t\t\trow.dirty = true;\n\t\t\tmodified = true;\n\t\t}\n\t}\n\tif (modified) {\n\t\tcleanupPermutations(rows, row);\n\t}\n\treturn modified;\n}\n\n/**\n * If the given row contains a single permutation, remove that permutation from the other rows.\n * @param {!module:rows~Rows} rows - rows on a board\n * @param {!module:rows~Row} row - row to cleanup\n */\nfunction cleanupPermutations(rows, row) {\n\tif (1 !== row.raw.length) {\n\t\treturn;\n\t}\n\tvar rawPermutation = row.raw[0];\n\tfor (var i = 0; i < rows.length; i++) {\n\t\tvar otherRow = rows[i];\n\t\tif (row === otherRow) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar j = otherRow.raw.indexOf(rawPermutation);\n\t\tif (-1 !== j) {\n\t\t\totherRow.raw.splice(j, 1);\n\t\t\totherRow.dirty = true;\n\t\t}\n\t}\n}\n\nmodule.exports = {\n\tcreate: createRows,\n\tdirty: isRowDirty,\n\tget: getState,\n\tset: setState,\n\t// these are only exported for unit tests\n\t_isPermutationValid: isPermutationValid\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/rows.js\n// module id = 4\n// module chunks = 0"]}